"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlParser = void 0;
const parse5_1 = require("parse5");
const errorHandler_1 = require("./errorHandler");
// Make vscode import optional for testing
let vscode;
try {
    vscode = require('vscode');
}
catch {
    // Use mock for testing
    vscode = {
        Position: class Position {
            constructor(line, character) {
                this.line = line;
                this.character = character;
            }
        },
        Range: class Range {
            constructor(start, end) {
                this.start = start;
                this.end = end;
            }
        }
    };
}
class HtmlParser {
    /**
     * Parses HTML content and extracts web platform features
     * @param content HTML content to parse
     * @param document Optional VS Code document for position mapping
     * @returns Parse result with features and their locations
     */
    static parseHtml(content, document) {
        const features = [];
        const locations = new Map();
        try {
            // Validate input
            if (!content || typeof content !== 'string') {
                this.errorHandler.handleValidationError('Invalid HTML content provided', 'HTML parsing validation');
                return { features: [], locations: new Map() };
            }
            // Parse HTML with parse5 for standards-compliant parsing
            const htmlDocument = (0, parse5_1.parse)(content, {
                sourceCodeLocationInfo: true // Enable location tracking for ranges
            });
            // Traverse the HTML AST to find web platform features
            this.traverseNode(htmlDocument, features, locations, document);
        }
        catch (error) {
            // Handle HTML parsing errors gracefully with error recovery
            this.errorHandler.handleParserError(error instanceof Error ? error : new Error('Unknown HTML parsing error'), 'HTML', 'Parsing HTML content with parse5');
            // Return empty result on parse failure
            return { features: [], locations: new Map() };
        }
        return { features, locations };
    }
    /**
     * Recursively traverses HTML nodes to extract features
     * @param node Current HTML node
     * @param features Array to collect feature IDs
     * @param locations Map to collect feature locations
     * @param document Optional VS Code document for position mapping
     */
    static traverseNode(node, features, locations, document) {
        // Handle element nodes
        if (node.nodeName && node.nodeName !== '#document' && node.nodeName !== '#text' && node.nodeName !== '#comment') {
            const element = node;
            // Only process elements that have actual source code location (not auto-generated by parse5)
            // Parse5 automatically adds html, head, body elements even for empty content
            const hasRealSourceLocation = element.sourceCodeLocation &&
                element.sourceCodeLocation.startTag &&
                element.sourceCodeLocation.startTag.startLine > 0;
            // Extract element feature only if it has a real source location or if we're not being strict about it
            if (element.tagName && (hasRealSourceLocation || this.shouldIncludeElement(element.tagName))) {
                const elementFeatureId = this.mapElementToFeatureId(element.tagName);
                if (elementFeatureId && !features.includes(elementFeatureId)) {
                    features.push(elementFeatureId);
                    // Track location if document is provided and element has real location
                    if (document && hasRealSourceLocation) {
                        const range = this.getElementRange(element, document);
                        if (range) {
                            if (!locations.has(elementFeatureId)) {
                                locations.set(elementFeatureId, []);
                            }
                            locations.get(elementFeatureId).push(range);
                        }
                    }
                }
                // Extract attribute features
                if (element.attrs && hasRealSourceLocation) {
                    for (const attr of element.attrs) {
                        const attrFeatureId = this.mapAttributeToFeatureId(attr.name, element.tagName);
                        if (attrFeatureId && !features.includes(attrFeatureId)) {
                            features.push(attrFeatureId);
                            // Track attribute location if document is provided
                            if (document && element.sourceCodeLocation?.attrs?.[attr.name]) {
                                const range = this.getAttributeRange(element, attr.name, document);
                                if (range) {
                                    if (!locations.has(attrFeatureId)) {
                                        locations.set(attrFeatureId, []);
                                    }
                                    locations.get(attrFeatureId).push(range);
                                }
                            }
                        }
                        // Special handling for input type values
                        if (element.tagName === 'input' && attr.name === 'type') {
                            const inputTypeFeatureId = this.mapInputTypeToFeatureId(attr.value);
                            if (inputTypeFeatureId && !features.includes(inputTypeFeatureId)) {
                                features.push(inputTypeFeatureId);
                                // Track input type location
                                if (document && element.sourceCodeLocation?.attrs?.[attr.name]) {
                                    const range = this.getAttributeRange(element, attr.name, document);
                                    if (range) {
                                        if (!locations.has(inputTypeFeatureId)) {
                                            locations.set(inputTypeFeatureId, []);
                                        }
                                        locations.get(inputTypeFeatureId).push(range);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Handle template content specially
        if (node.nodeName === 'template' && 'content' in node && node.content) {
            // Template content is stored in a separate document fragment
            this.traverseNode(node.content, features, locations, document);
        }
        // Recursively traverse child nodes
        if ('childNodes' in node && node.childNodes) {
            for (const child of node.childNodes) {
                this.traverseNode(child, features, locations, document);
            }
        }
    }
    /**
     * Determines if an element should be included even without source location
     * This helps filter out auto-generated elements by parse5
     * @param tagName Element tag name
     * @returns true if element should be included
     */
    static shouldIncludeElement(tagName) {
        // Don't include basic structural elements that parse5 auto-generates
        const autoGeneratedElements = new Set(['html', 'head', 'body']);
        return !autoGeneratedElements.has(tagName.toLowerCase());
    }
    /**
     * Maps HTML element names to web-features IDs
     * @param tagName HTML element tag name
     * @returns web-features ID or null if not mappable
     */
    static mapElementToFeatureId(tagName) {
        // Handle undefined or null tagName
        if (!tagName) {
            return null;
        }
        // Normalize tag name to lowercase
        const normalizedTag = tagName.toLowerCase();
        // Only flag HTML elements that are actually non-baseline or newer
        // Most HTML elements are universally supported and baseline
        const nonBaselineElements = new Set([
            'dialog',
            'details',
            'summary',
            'template',
            'slot',
            'picture',
            'source',
            'track',
            'progress',
            'meter',
            'datalist',
            'output',
            'time',
            'mark' // Text highlighting - may not be baseline
        ]);
        // Only return feature IDs for elements that need baseline checking
        if (nonBaselineElements.has(normalizedTag)) {
            return `html.elements.${normalizedTag}`;
        }
        // Also check for custom elements (contain hyphens)
        if (normalizedTag.includes('-')) {
            return `html.elements.custom`; // Custom elements may not be baseline
        }
        return null; // Skip checking universal HTML elements like div, p, span, etc.
    }
    /**
     * Maps HTML attributes to web-features IDs
     * @param attrName Attribute name
     * @param tagName Element tag name (for context-specific attributes)
     * @returns web-features ID or null if not mappable
     */
    static mapAttributeToFeatureId(attrName, tagName) {
        // Normalize attribute name to lowercase
        const normalizedAttr = attrName.toLowerCase();
        const normalizedTag = tagName.toLowerCase();
        // Global attributes that apply to all elements
        const globalAttributes = new Set([
            'accesskey', 'autocapitalize', 'autofocus', 'class', 'contenteditable',
            'contextmenu', 'dir', 'draggable', 'enterkeyhint', 'hidden', 'id',
            'inputmode', 'is', 'itemid', 'itemprop', 'itemref', 'itemscope',
            'itemtype', 'lang', 'nonce', 'part', 'role', 'slot', 'spellcheck',
            'style', 'tabindex', 'title', 'translate'
        ]);
        // Skip very common global attributes to reduce noise
        const commonGlobalAttributes = new Set([
            'class', 'id', 'style', 'title', 'lang', 'dir'
        ]);
        if (commonGlobalAttributes.has(normalizedAttr)) {
            return null; // Don't flag common attributes
        }
        // Element-specific attribute mappings for newer/notable attributes
        const elementSpecificAttributes = {
            'input': {
                'autocomplete': 'html.elements.input.autocomplete',
                'list': 'html.elements.input.list',
                'pattern': 'html.elements.input.pattern',
                'placeholder': 'html.elements.input.placeholder',
                'required': 'html.elements.input.required',
                'min': 'html.elements.input.min',
                'max': 'html.elements.input.max',
                'step': 'html.elements.input.step',
                'type': 'html.elements.input.type' // Need to check input type values
            },
            'form': {
                'novalidate': 'html.elements.form.novalidate'
            },
            'img': {
                'loading': 'html.elements.img.loading',
                'decoding': 'html.elements.img.decoding',
                'sizes': 'html.elements.img.sizes',
                'srcset': 'html.elements.img.srcset'
            },
            'iframe': {
                'loading': 'html.elements.iframe.loading',
                'sandbox': 'html.elements.iframe.sandbox',
                'allow': 'html.elements.iframe.allow',
                'referrerpolicy': 'html.elements.iframe.referrerpolicy'
            },
            'script': {
                'async': 'html.elements.script.async',
                'defer': 'html.elements.script.defer',
                'type': 'html.elements.script.type',
                'nomodule': 'html.elements.script.nomodule',
                'crossorigin': 'html.elements.script.crossorigin',
                'integrity': 'html.elements.script.integrity',
                'referrerpolicy': 'html.elements.script.referrerpolicy'
            },
            'link': {
                'crossorigin': 'html.elements.link.crossorigin',
                'integrity': 'html.elements.link.integrity',
                'referrerpolicy': 'html.elements.link.referrerpolicy',
                'as': 'html.elements.link.as',
                'preload': 'html.elements.link.preload'
            },
            'meta': {
                'charset': 'html.elements.meta.charset',
                'http-equiv': 'html.elements.meta.http-equiv'
            },
            'video': {
                'autoplay': 'html.elements.video.autoplay',
                'controls': 'html.elements.video.controls',
                'loop': 'html.elements.video.loop',
                'muted': 'html.elements.video.muted',
                'playsinline': 'html.elements.video.playsinline',
                'poster': 'html.elements.video.poster',
                'preload': 'html.elements.video.preload'
            },
            'audio': {
                'autoplay': 'html.elements.audio.autoplay',
                'controls': 'html.elements.audio.controls',
                'loop': 'html.elements.audio.loop',
                'muted': 'html.elements.audio.muted',
                'preload': 'html.elements.audio.preload'
            },
            'details': {
                'open': 'html.elements.details.open'
            },
            'dialog': {
                'open': 'html.elements.dialog.open'
            }
        };
        // Check for element-specific attributes
        if (elementSpecificAttributes[normalizedTag]?.[normalizedAttr]) {
            return elementSpecificAttributes[normalizedTag][normalizedAttr];
        }
        // Special handling for input type attribute values
        if (normalizedTag === 'input' && normalizedAttr === 'type') {
            // We need to check the actual type value, but that requires accessing the attribute value
            // This will be handled in a separate method when we have access to the attribute value
            return null; // Don't flag the type attribute itself, flag specific type values
        }
        // Notable global attributes that should be flagged
        const notableGlobalAttributes = {
            'contenteditable': 'html.global_attributes.contenteditable',
            'draggable': 'html.global_attributes.draggable',
            'hidden': 'html.global_attributes.hidden',
            'spellcheck': 'html.global_attributes.spellcheck',
            'translate': 'html.global_attributes.translate',
            'autocapitalize': 'html.global_attributes.autocapitalize',
            'enterkeyhint': 'html.global_attributes.enterkeyhint',
            'inputmode': 'html.global_attributes.inputmode',
            'is': 'html.global_attributes.is',
            'itemid': 'html.global_attributes.itemid',
            'itemprop': 'html.global_attributes.itemprop',
            'itemref': 'html.global_attributes.itemref',
            'itemscope': 'html.global_attributes.itemscope',
            'itemtype': 'html.global_attributes.itemtype',
            'nonce': 'html.global_attributes.nonce',
            'part': 'html.global_attributes.part',
            'slot': 'html.global_attributes.slot'
        };
        if (notableGlobalAttributes[normalizedAttr]) {
            return notableGlobalAttributes[normalizedAttr];
        }
        // Data attributes and aria attributes are generally well-supported, skip them
        if (normalizedAttr.startsWith('data-') || normalizedAttr.startsWith('aria-')) {
            return null;
        }
        // Event handler attributes (onclick, onload, etc.) are generally well-supported
        if (normalizedAttr.startsWith('on')) {
            return null;
        }
        // For other attributes, create a generic mapping
        return `html.attributes.${normalizedAttr}`;
    }
    /**
     * Maps input type values to web-features IDs
     * @param typeValue Input type attribute value
     * @returns web-features ID or null if not mappable
     */
    static mapInputTypeToFeatureId(typeValue) {
        if (!typeValue) {
            return null;
        }
        // Normalize type value to lowercase
        const normalizedType = typeValue.toLowerCase();
        // Only flag newer/potentially non-baseline input types
        // Basic types like text, password, submit, button are universally supported
        const nonBaselineInputTypes = new Set([
            'color',
            'date',
            'datetime-local',
            'email',
            'month',
            'number',
            'range',
            'search',
            'tel',
            'time',
            'url',
            'week' // Week picker - may not be baseline
        ]);
        if (nonBaselineInputTypes.has(normalizedType)) {
            return `html.elements.input.type.${normalizedType}`;
        }
        return null; // Skip baseline input types like text, password, submit, etc.
    }
    /**
     * Gets the VS Code range for an HTML element
     * @param element HTML element node
     * @param document VS Code document
     * @returns VS Code range or null if not determinable
     */
    static getElementRange(element, document) {
        if (!element.sourceCodeLocation?.startTag) {
            return null;
        }
        try {
            const startLoc = element.sourceCodeLocation.startTag;
            const startPos = new vscode.Position(startLoc.startLine - 1, // parse5 uses 1-based line numbers
            startLoc.startCol - 1 // parse5 uses 1-based column numbers
            );
            // Highlight just the tag name, not the entire opening tag
            const tagEndCol = startLoc.startCol - 1 + element.tagName.length + 1; // +1 for <
            const endPos = new vscode.Position(startLoc.startLine - 1, tagEndCol);
            return new vscode.Range(startPos, endPos);
        }
        catch (error) {
            this.errorHandler.handleParserError(error instanceof Error ? error : new Error('Unknown error creating HTML element range'), 'HTML', 'Creating VS Code range for HTML element');
            return null;
        }
    }
    /**
     * Gets the VS Code range for an HTML attribute
     * @param element HTML element node
     * @param attrName Attribute name
     * @param document VS Code document
     * @returns VS Code range or null if not determinable
     */
    static getAttributeRange(element, attrName, document) {
        const attrLocation = element.sourceCodeLocation?.attrs?.[attrName];
        if (!attrLocation) {
            return null;
        }
        try {
            const startPos = new vscode.Position(attrLocation.startLine - 1, // parse5 uses 1-based line numbers
            attrLocation.startCol - 1 // parse5 uses 1-based column numbers
            );
            const endPos = new vscode.Position(attrLocation.endLine - 1, attrLocation.endCol - 1);
            return new vscode.Range(startPos, endPos);
        }
        catch (error) {
            this.errorHandler.handleParserError(error instanceof Error ? error : new Error('Unknown error creating HTML attribute range'), 'HTML', 'Creating VS Code range for HTML attribute');
            return null;
        }
    }
    /**
     * Extracts just the feature IDs without location information
     * @param content HTML content to parse
     * @returns Array of web-features IDs
     */
    static extractFeatures(content) {
        const result = this.parseHtml(content);
        return result.features;
    }
}
exports.HtmlParser = HtmlParser;
HtmlParser.errorHandler = errorHandler_1.ErrorHandler.getInstance();
//# sourceMappingURL=htmlParser.js.map