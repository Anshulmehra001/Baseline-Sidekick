import { parse, DefaultTreeAdapterMap } from 'parse5';
import type { Document, Element, TextNode, CommentNode, DocumentType } from 'parse5/dist/tree-adapters/default';
import { ErrorHandler } from './errorHandler';

// Make vscode import optional for testing
let vscode: any;
try {
  vscode = require('vscode');
} catch {
  // Use mock for testing
  vscode = {
    Position: class Position {
      constructor(public line: number, public character: number) {}
    },
    Range: class Range {
      constructor(public start: any, public end: any) {}
    }
  };
}

export interface HtmlParseResult {
  features: string[];
  locations: Map<string, any[]>; // Use any for VS Code Range to avoid import issues in tests
}

export class HtmlParser {
  private static errorHandler = ErrorHandler.getInstance();

  /**
   * Parses HTML content and extracts web platform features
   * @param content HTML content to parse
   * @param document Optional VS Code document for position mapping
   * @returns Parse result with features and their locations
   */
  public static parseHtml(content: string, document?: any): HtmlParseResult {
    const features: string[] = [];
    const locations = new Map<string, any[]>();

    try {
      // Validate input
      if (!content || typeof content !== 'string') {
        this.errorHandler.handleValidationError('Invalid HTML content provided', 'HTML parsing validation');
        return { features: [], locations: new Map() };
      }
      // Parse HTML with parse5 for standards-compliant parsing
      const htmlDocument = parse(content, {
        sourceCodeLocationInfo: true // Enable location tracking for ranges
      }) as Document;

      // Traverse the HTML AST to find web platform features
      this.traverseNode(htmlDocument, features, locations, document);

    } catch (error) {
      // Handle HTML parsing errors gracefully with error recovery
      this.errorHandler.handleParserError(
        error instanceof Error ? error : new Error('Unknown HTML parsing error'),
        'HTML',
        'Parsing HTML content with parse5'
      );
      // Return empty result on parse failure
      return { features: [], locations: new Map() };
    }

    return { features, locations };
  }

  /**
   * Recursively traverses HTML nodes to extract features
   * @param node Current HTML node
   * @param features Array to collect feature IDs
   * @param locations Map to collect feature locations
   * @param document Optional VS Code document for position mapping
   */
  private static traverseNode(
    node: DefaultTreeAdapterMap['node'],
    features: string[],
    locations: Map<string, any[]>,
    document?: any
  ): void {
    // Handle element nodes
    if (node.nodeName && node.nodeName !== '#document' && node.nodeName !== '#text' && node.nodeName !== '#comment') {
      const element = node as Element;
      
      // Only process elements that have actual source code location (not auto-generated by parse5)
      // Parse5 automatically adds html, head, body elements even for empty content
      const hasRealSourceLocation = element.sourceCodeLocation && 
        element.sourceCodeLocation.startTag && 
        element.sourceCodeLocation.startTag.startLine > 0;
      
      // Extract element feature only if it has a real source location or if we're not being strict about it
      if (element.tagName && (hasRealSourceLocation || this.shouldIncludeElement(element.tagName))) {
        const elementFeatureId = this.mapElementToFeatureId(element.tagName);
        if (elementFeatureId && !features.includes(elementFeatureId)) {
          features.push(elementFeatureId);
          
          // Track location if document is provided and element has real location
          if (document && hasRealSourceLocation) {
            const range = this.getElementRange(element, document);
            if (range) {
              if (!locations.has(elementFeatureId)) {
                locations.set(elementFeatureId, []);
              }
              locations.get(elementFeatureId)!.push(range);
            }
          }
        }

        // Extract attribute features
        if (element.attrs && hasRealSourceLocation) {
          for (const attr of element.attrs) {
            const attrFeatureId = this.mapAttributeToFeatureId(attr.name, element.tagName);
            if (attrFeatureId && !features.includes(attrFeatureId)) {
              features.push(attrFeatureId);
              
              // Track attribute location if document is provided
              if (document && element.sourceCodeLocation?.attrs?.[attr.name]) {
                const range = this.getAttributeRange(element, attr.name, document);
                if (range) {
                  if (!locations.has(attrFeatureId)) {
                    locations.set(attrFeatureId, []);
                  }
                  locations.get(attrFeatureId)!.push(range);
                }
              }
            }
          }
        }
      }
    }

    // Handle template content specially
    if (node.nodeName === 'template' && 'content' in node && node.content) {
      // Template content is stored in a separate document fragment
      this.traverseNode(node.content, features, locations, document);
    }

    // Recursively traverse child nodes
    if ('childNodes' in node && node.childNodes) {
      for (const child of node.childNodes) {
        this.traverseNode(child, features, locations, document);
      }
    }
  }

  /**
   * Determines if an element should be included even without source location
   * This helps filter out auto-generated elements by parse5
   * @param tagName Element tag name
   * @returns true if element should be included
   */
  private static shouldIncludeElement(tagName: string): boolean {
    // Don't include basic structural elements that parse5 auto-generates
    const autoGeneratedElements = new Set(['html', 'head', 'body']);
    return !autoGeneratedElements.has(tagName.toLowerCase());
  }

  /**
   * Maps HTML element names to web-features IDs
   * @param tagName HTML element tag name
   * @returns web-features ID or null if not mappable
   */
  private static mapElementToFeatureId(tagName: string): string | null {
    // Handle undefined or null tagName
    if (!tagName) {
      return null;
    }
    
    // Normalize tag name to lowercase
    const normalizedTag = tagName.toLowerCase();
    
    // Map HTML elements to web-features IDs
    // Format: html.elements.{element-name}
    return `html.elements.${normalizedTag}`;
  }

  /**
   * Maps HTML attributes to web-features IDs
   * @param attrName Attribute name
   * @param tagName Element tag name (for context-specific attributes)
   * @returns web-features ID or null if not mappable
   */
  private static mapAttributeToFeatureId(attrName: string, tagName: string): string | null {
    // Normalize attribute name to lowercase
    const normalizedAttr = attrName.toLowerCase();
    const normalizedTag = tagName.toLowerCase();
    
    // Global attributes that apply to all elements
    const globalAttributes = new Set([
      'accesskey', 'autocapitalize', 'autofocus', 'class', 'contenteditable',
      'contextmenu', 'dir', 'draggable', 'enterkeyhint', 'hidden', 'id',
      'inputmode', 'is', 'itemid', 'itemprop', 'itemref', 'itemscope',
      'itemtype', 'lang', 'nonce', 'part', 'role', 'slot', 'spellcheck',
      'style', 'tabindex', 'title', 'translate'
    ]);

    // Skip very common global attributes to reduce noise
    const commonGlobalAttributes = new Set([
      'class', 'id', 'style', 'title', 'lang', 'dir'
    ]);

    if (commonGlobalAttributes.has(normalizedAttr)) {
      return null; // Don't flag common attributes
    }

    // Element-specific attribute mappings for newer/notable attributes
    const elementSpecificAttributes: Record<string, Record<string, string>> = {
      'input': {
        'autocomplete': 'html.elements.input.autocomplete',
        'list': 'html.elements.input.list',
        'pattern': 'html.elements.input.pattern',
        'placeholder': 'html.elements.input.placeholder',
        'required': 'html.elements.input.required',
        'min': 'html.elements.input.min',
        'max': 'html.elements.input.max',
        'step': 'html.elements.input.step'
      },
      'form': {
        'novalidate': 'html.elements.form.novalidate'
      },
      'img': {
        'loading': 'html.elements.img.loading',
        'decoding': 'html.elements.img.decoding',
        'sizes': 'html.elements.img.sizes',
        'srcset': 'html.elements.img.srcset'
      },
      'iframe': {
        'loading': 'html.elements.iframe.loading',
        'sandbox': 'html.elements.iframe.sandbox',
        'allow': 'html.elements.iframe.allow',
        'referrerpolicy': 'html.elements.iframe.referrerpolicy'
      },
      'script': {
        'async': 'html.elements.script.async',
        'defer': 'html.elements.script.defer',
        'type': 'html.elements.script.type',
        'nomodule': 'html.elements.script.nomodule',
        'crossorigin': 'html.elements.script.crossorigin',
        'integrity': 'html.elements.script.integrity',
        'referrerpolicy': 'html.elements.script.referrerpolicy'
      },
      'link': {
        'crossorigin': 'html.elements.link.crossorigin',
        'integrity': 'html.elements.link.integrity',
        'referrerpolicy': 'html.elements.link.referrerpolicy',
        'as': 'html.elements.link.as',
        'preload': 'html.elements.link.preload'
      },
      'meta': {
        'charset': 'html.elements.meta.charset',
        'http-equiv': 'html.elements.meta.http-equiv'
      },
      'video': {
        'autoplay': 'html.elements.video.autoplay',
        'controls': 'html.elements.video.controls',
        'loop': 'html.elements.video.loop',
        'muted': 'html.elements.video.muted',
        'playsinline': 'html.elements.video.playsinline',
        'poster': 'html.elements.video.poster',
        'preload': 'html.elements.video.preload'
      },
      'audio': {
        'autoplay': 'html.elements.audio.autoplay',
        'controls': 'html.elements.audio.controls',
        'loop': 'html.elements.audio.loop',
        'muted': 'html.elements.audio.muted',
        'preload': 'html.elements.audio.preload'
      },
      'details': {
        'open': 'html.elements.details.open'
      },
      'dialog': {
        'open': 'html.elements.dialog.open'
      }
    };

    // Check for element-specific attributes
    if (elementSpecificAttributes[normalizedTag]?.[normalizedAttr]) {
      return elementSpecificAttributes[normalizedTag][normalizedAttr];
    }

    // Notable global attributes that should be flagged
    const notableGlobalAttributes: Record<string, string> = {
      'contenteditable': 'html.global_attributes.contenteditable',
      'draggable': 'html.global_attributes.draggable',
      'hidden': 'html.global_attributes.hidden',
      'spellcheck': 'html.global_attributes.spellcheck',
      'translate': 'html.global_attributes.translate',
      'autocapitalize': 'html.global_attributes.autocapitalize',
      'enterkeyhint': 'html.global_attributes.enterkeyhint',
      'inputmode': 'html.global_attributes.inputmode',
      'is': 'html.global_attributes.is',
      'itemid': 'html.global_attributes.itemid',
      'itemprop': 'html.global_attributes.itemprop',
      'itemref': 'html.global_attributes.itemref',
      'itemscope': 'html.global_attributes.itemscope',
      'itemtype': 'html.global_attributes.itemtype',
      'nonce': 'html.global_attributes.nonce',
      'part': 'html.global_attributes.part',
      'slot': 'html.global_attributes.slot'
    };

    if (notableGlobalAttributes[normalizedAttr]) {
      return notableGlobalAttributes[normalizedAttr];
    }

    // Data attributes and aria attributes are generally well-supported, skip them
    if (normalizedAttr.startsWith('data-') || normalizedAttr.startsWith('aria-')) {
      return null;
    }

    // Event handler attributes (onclick, onload, etc.) are generally well-supported
    if (normalizedAttr.startsWith('on')) {
      return null;
    }

    // For other attributes, create a generic mapping
    return `html.attributes.${normalizedAttr}`;
  }

  /**
   * Gets the VS Code range for an HTML element
   * @param element HTML element node
   * @param document VS Code document
   * @returns VS Code range or null if not determinable
   */
  private static getElementRange(element: Element, document: any): any | null {
    if (!element.sourceCodeLocation?.startTag) {
      return null;
    }

    try {
      const startLoc = element.sourceCodeLocation.startTag;
      const startPos = new vscode.Position(
        startLoc.startLine - 1, // parse5 uses 1-based line numbers
        startLoc.startCol - 1   // parse5 uses 1-based column numbers
      );
      
      // Highlight just the tag name, not the entire opening tag
      const tagEndCol = startLoc.startCol - 1 + element.tagName.length + 1; // +1 for <
      const endPos = new vscode.Position(
        startLoc.startLine - 1,
        tagEndCol
      );

      return new vscode.Range(startPos, endPos);
    } catch (error) {
      this.errorHandler.handleParserError(
        error instanceof Error ? error : new Error('Unknown error creating HTML element range'),
        'HTML',
        'Creating VS Code range for HTML element'
      );
      return null;
    }
  }

  /**
   * Gets the VS Code range for an HTML attribute
   * @param element HTML element node
   * @param attrName Attribute name
   * @param document VS Code document
   * @returns VS Code range or null if not determinable
   */
  private static getAttributeRange(element: Element, attrName: string, document: any): any | null {
    const attrLocation = element.sourceCodeLocation?.attrs?.[attrName];
    if (!attrLocation) {
      return null;
    }

    try {
      const startPos = new vscode.Position(
        attrLocation.startLine - 1, // parse5 uses 1-based line numbers
        attrLocation.startCol - 1   // parse5 uses 1-based column numbers
      );
      
      const endPos = new vscode.Position(
        attrLocation.endLine - 1,
        attrLocation.endCol - 1
      );

      return new vscode.Range(startPos, endPos);
    } catch (error) {
      this.errorHandler.handleParserError(
        error instanceof Error ? error : new Error('Unknown error creating HTML attribute range'),
        'HTML',
        'Creating VS Code range for HTML attribute'
      );
      return null;
    }
  }

  /**
   * Extracts just the feature IDs without location information
   * @param content HTML content to parse
   * @returns Array of web-features IDs
   */
  public static extractFeatures(content: string): string[] {
    const result = this.parseHtml(content);
    return result.features;
  }
}